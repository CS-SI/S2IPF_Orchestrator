#!/usr/bin/env python
# coding=utf-8
#   _________________ .________________________
#  /   _____/\_____  \|   \______   \_   _____/
#  \_____  \  /  ____/|   ||     ___/|    __)
#  /        \/       \|   ||    |    |     \
# /_______  /\_______ \___||____|    \___  /
#         \/         \/                  \/
# ________                .__                     __                 __
# \_____  \_______   ____ |  |__   ____   _______/  |_____________ _/  |_  ___________
#  /   |   \_  __ \_/ ___\|  |  \_/ __ \ /  ___/\   __\_  __ \__  \\   __\/  _ \_  __ \
# /    |    \  | \/\  \___|   Y  \  ___/ \___ \  |  |  |  | \// __ \|  | (  <_> )  | \/
# \_______  /__|    \___  >___|  /\___  >____  > |__|  |__|  (____  /__|  \____/|__|
#         \/            \/     \/     \/     \/                   \/
#
#
#  Copyright (C) 2014-2022 CS GROUP â€“ France, https://www.csgroup.eu
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# author : Esquis Benjamin for CSGroup
#
#
# Generated Tue Jun 03 11:16:24 2014 by generateDS.py version 2.12d.
#
# Command line options:
#   ('-o', 'TaskTableReader.py')
#
# Command line arguments:
#   TaskTable_L0cBeta.xsd
#
# Command line:
#   C:\Python27\Scripts\generateDS.py -o "TaskTableReader.py" TaskTable_L0cBeta.xsd
#
# Current working directory (os.getcwd()):
#   tests
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class PoolType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Detached=False, Killing_Signal=9, List_of_Tasks=None):
        self.original_tagname_ = None
        self.Detached = Detached
        self.Killing_Signal = Killing_Signal
        self.List_of_Tasks = List_of_Tasks
    def factory(*args_, **kwargs_):
        if PoolType.subclass:
            return PoolType.subclass(*args_, **kwargs_)
        else:
            return PoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Detached(self): return self.Detached
    def set_Detached(self, Detached): self.Detached = Detached
    def get_Killing_Signal(self): return self.Killing_Signal
    def set_Killing_Signal(self, Killing_Signal): self.Killing_Signal = Killing_Signal
    def get_List_of_Tasks(self): return self.List_of_Tasks
    def set_List_of_Tasks(self, List_of_Tasks): self.List_of_Tasks = List_of_Tasks
    def validate_Killing_SignalType(self, value):
        # Validate type Killing_SignalType, a restriction on xs:positiveInteger.
        pass
    def hasContent_(self):
        if (
            self.Detached is not None or
            self.Killing_Signal is not None or
            self.List_of_Tasks is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PoolType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PoolType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PoolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Detached is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDetached>%s</%sDetached>%s' % (namespace_, self.gds_format_boolean(self.Detached, input_name='Detached'), namespace_, eol_))
        if self.Killing_Signal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKilling_Signal>%s</%sKilling_Signal>%s' % (namespace_, self.gds_format_integer(self.Killing_Signal, input_name='Killing_Signal'), namespace_, eol_))
        if self.List_of_Tasks is not None:
            self.List_of_Tasks.export(outfile, level, namespace_, name_='List_of_Tasks', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PoolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Detached is not None:
            showIndent(outfile, level)
            outfile.write('Detached=%s,\n' % self.Detached)
        if self.Killing_Signal is not None:
            showIndent(outfile, level)
            outfile.write('Killing_Signal=%d,\n' % self.Killing_Signal)
        if self.List_of_Tasks is not None:
            showIndent(outfile, level)
            outfile.write('List_of_Tasks=model_.List_of_TasksType(\n')
            self.List_of_Tasks.exportLiteral(outfile, level, name_='List_of_Tasks')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Detached':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Detached')
            self.Detached = ival_
        elif nodeName_ == 'Killing_Signal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Killing_Signal')
            self.Killing_Signal = ival_
            self.validate_Killing_SignalType(self.Killing_Signal)    # validate type Killing_SignalType
        elif nodeName_ == 'List_of_Tasks':
            obj_ = List_of_TasksType.factory()
            obj_.build(child_)
            self.List_of_Tasks = obj_
            obj_.original_tagname_ = 'List_of_Tasks'
# end class PoolType


class List_of_Cfg_FilesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Cfg_File=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        if Cfg_File is None:
            self.Cfg_File = []
        else:
            self.Cfg_File = Cfg_File
    def factory(*args_, **kwargs_):
        if List_of_Cfg_FilesType.subclass:
            return List_of_Cfg_FilesType.subclass(*args_, **kwargs_)
        else:
            return List_of_Cfg_FilesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cfg_File(self): return self.Cfg_File
    def set_Cfg_File(self, Cfg_File): self.Cfg_File = Cfg_File
    def add_Cfg_File(self, value): self.Cfg_File.append(value)
    def insert_Cfg_File(self, index, value): self.Cfg_File[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.Cfg_File
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List_of_Cfg_FilesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List_of_Cfg_FilesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='List_of_Cfg_FilesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List_of_Cfg_FilesType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (self.gds_format_string(quote_attrib(self.count).encode(ExternalEncoding), input_name='count'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='List_of_Cfg_FilesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Cfg_File_ in self.Cfg_File:
            Cfg_File_.export(outfile, level, namespace_, name_='Cfg_File', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='List_of_Cfg_FilesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count="%s",\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Cfg_File=[\n')
        level += 1
        for Cfg_File_ in self.Cfg_File:
            showIndent(outfile, level)
            outfile.write('model_.Cfg_FilesType(\n')
            Cfg_File_.exportLiteral(outfile, level, name_='Cfg_FilesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cfg_File':
            obj_ = Cfg_FilesType.factory()
            obj_.build(child_)
            self.Cfg_File.append(obj_)
            obj_.original_tagname_ = 'Cfg_File'
# end class List_of_Cfg_FilesType


class InputType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None, id=None, Mode='ALWAYS', Mandatory=None, List_of_Alternatives=None):
        self.original_tagname_ = None
        self.ref = _cast(None, ref)
        self.id = _cast(None, id)
        self.Mode = Mode
        self.Mandatory = Mandatory
        self.List_of_Alternatives = List_of_Alternatives
    def factory(*args_, **kwargs_):
        if InputType.subclass:
            return InputType.subclass(*args_, **kwargs_)
        else:
            return InputType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Mode(self): return self.Mode
    def set_Mode(self, Mode): self.Mode = Mode
    def get_Mandatory(self): return self.Mandatory
    def set_Mandatory(self, Mandatory): self.Mandatory = Mandatory
    def get_List_of_Alternatives(self): return self.List_of_Alternatives
    def set_List_of_Alternatives(self, List_of_Alternatives): self.List_of_Alternatives = List_of_Alternatives
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_ModeType(self, value):
        # Validate type ModeType, a restriction on xs:string.
        pass
    def validate_MandatoryType(self, value):
        # Validate type MandatoryType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Mode is not None or
            self.Mandatory is not None or
            self.List_of_Alternatives is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InputType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InputType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InputType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InputType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InputType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMode>%s</%sMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.Mode).encode(ExternalEncoding), input_name='Mode'), namespace_, eol_))
        if self.Mandatory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMandatory>%s</%sMandatory>%s' % (namespace_, self.gds_format_string(quote_xml(self.Mandatory).encode(ExternalEncoding), input_name='Mandatory'), namespace_, eol_))
        if self.List_of_Alternatives is not None:
            self.List_of_Alternatives.export(outfile, level, namespace_, name_='List_of_Alternatives', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InputType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Mode is not None:
            showIndent(outfile, level)
            outfile.write('Mode=%s,\n' % quote_python(self.Mode).encode(ExternalEncoding))
        if self.Mandatory is not None:
            showIndent(outfile, level)
            outfile.write('Mandatory=%s,\n' % quote_python(self.Mandatory).encode(ExternalEncoding))
        if self.List_of_Alternatives is not None:
            showIndent(outfile, level)
            outfile.write('List_of_Alternatives=model_.List_of_AlternativesType(\n')
            self.List_of_Alternatives.exportLiteral(outfile, level, name_='List_of_Alternatives')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Mode':
            Mode_ = child_.text
            Mode_ = self.gds_validate_string(Mode_, node, 'Mode')
            self.Mode = Mode_
            self.validate_ModeType(self.Mode)    # validate type ModeType
        elif nodeName_ == 'Mandatory':
            Mandatory_ = child_.text
            Mandatory_ = self.gds_validate_string(Mandatory_, node, 'Mandatory')
            self.Mandatory = Mandatory_
            self.validate_MandatoryType(self.Mandatory)    # validate type MandatoryType
        elif nodeName_ == 'List_of_Alternatives':
            obj_ = List_of_AlternativesType.factory()
            obj_.build(child_)
            self.List_of_Alternatives = obj_
            obj_.original_tagname_ = 'List_of_Alternatives'
# end class InputType


class List_of_TasksType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Task=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        if Task is None:
            self.Task = []
        else:
            self.Task = Task
    def factory(*args_, **kwargs_):
        if List_of_TasksType.subclass:
            return List_of_TasksType.subclass(*args_, **kwargs_)
        else:
            return List_of_TasksType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Task(self): return self.Task
    def set_Task(self, Task): self.Task = Task
    def add_Task(self, value): self.Task.append(value)
    def insert_Task(self, index, value): self.Task[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.Task
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List_of_TasksType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List_of_TasksType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='List_of_TasksType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List_of_TasksType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (self.gds_format_string(quote_attrib(self.count).encode(ExternalEncoding), input_name='count'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='List_of_TasksType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Task_ in self.Task:
            Task_.export(outfile, level, namespace_, name_='Task', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='List_of_TasksType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count="%s",\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Task=[\n')
        level += 1
        for Task_ in self.Task:
            showIndent(outfile, level)
            outfile.write('model_.TaskType(\n')
            Task_.exportLiteral(outfile, level, name_='TaskType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Task':
            obj_ = TaskType.factory()
            obj_.build(child_)
            self.Task.append(obj_)
            obj_.original_tagname_ = 'Task'
# end class List_of_TasksType


class AlternativeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Order=None, Origin='DB', Retrieval_Mode='LatestValidityClosest', T0=0, T1=0, File_Type=None, File_Name_Type='Physical'):
        self.original_tagname_ = None
        self.Order = Order
        self.Origin = Origin
        self.Retrieval_Mode = Retrieval_Mode
        self.T0 = T0
        self.T1 = T1
        self.File_Type = File_Type
        self.File_Name_Type = File_Name_Type
    def factory(*args_, **kwargs_):
        if AlternativeType.subclass:
            return AlternativeType.subclass(*args_, **kwargs_)
        else:
            return AlternativeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Order(self): return self.Order
    def set_Order(self, Order): self.Order = Order
    def get_Origin(self): return self.Origin
    def set_Origin(self, Origin): self.Origin = Origin
    def get_Retrieval_Mode(self): return self.Retrieval_Mode
    def set_Retrieval_Mode(self, Retrieval_Mode): self.Retrieval_Mode = Retrieval_Mode
    def get_T0(self): return self.T0
    def set_T0(self, T0): self.T0 = T0
    def get_T1(self): return self.T1
    def set_T1(self, T1): self.T1 = T1
    def get_File_Type(self): return self.File_Type
    def set_File_Type(self, File_Type): self.File_Type = File_Type
    def get_File_Name_Type(self): return self.File_Name_Type
    def set_File_Name_Type(self, File_Name_Type): self.File_Name_Type = File_Name_Type
    def validate_OriginType(self, value):
        # Validate type OriginType, a restriction on xs:string.
        pass
    def validate_Retrieval_ModeType(self, value):
        # Validate type Retrieval_ModeType, a restriction on xs:string.
        pass
    def validate_File_Name_TypeType(self, value):
        # Validate type File_Name_TypeType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Order is not None or
            self.Origin is not None or
            self.Retrieval_Mode is not None or
            self.T0 is not None or
            self.T1 is not None or
            self.File_Type is not None or
            self.File_Name_Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AlternativeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlternativeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AlternativeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AlternativeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AlternativeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Order is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrder>%s</%sOrder>%s' % (namespace_, self.gds_format_string(quote_xml(self.Order).encode(ExternalEncoding), input_name='Order'), namespace_, eol_))
        if self.Origin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrigin>%s</%sOrigin>%s' % (namespace_, self.gds_format_string(quote_xml(self.Origin).encode(ExternalEncoding), input_name='Origin'), namespace_, eol_))
        if self.Retrieval_Mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRetrieval_Mode>%s</%sRetrieval_Mode>%s' % (namespace_, self.gds_format_string(quote_xml(self.Retrieval_Mode).encode(ExternalEncoding), input_name='Retrieval_Mode'), namespace_, eol_))
        if self.T0 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sT0>%s</%sT0>%s' % (namespace_, self.gds_format_double(self.T0, input_name='T0'), namespace_, eol_))
        if self.T1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sT1>%s</%sT1>%s' % (namespace_, self.gds_format_double(self.T1, input_name='T1'), namespace_, eol_))
        if self.File_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Type>%s</%sFile_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Type).encode(ExternalEncoding), input_name='File_Type'), namespace_, eol_))
        if self.File_Name_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Name_Type>%s</%sFile_Name_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Name_Type).encode(ExternalEncoding), input_name='File_Name_Type'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AlternativeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Order is not None:
            showIndent(outfile, level)
            outfile.write('Order=%s,\n' % quote_python(self.Order).encode(ExternalEncoding))
        if self.Origin is not None:
            showIndent(outfile, level)
            outfile.write('Origin=%s,\n' % quote_python(self.Origin).encode(ExternalEncoding))
        if self.Retrieval_Mode is not None:
            showIndent(outfile, level)
            outfile.write('Retrieval_Mode=%s,\n' % quote_python(self.Retrieval_Mode).encode(ExternalEncoding))
        if self.T0 is not None:
            showIndent(outfile, level)
            outfile.write('T0=%e,\n' % self.T0)
        if self.T1 is not None:
            showIndent(outfile, level)
            outfile.write('T1=%e,\n' % self.T1)
        if self.File_Type is not None:
            showIndent(outfile, level)
            outfile.write('File_Type=%s,\n' % quote_python(self.File_Type).encode(ExternalEncoding))
        if self.File_Name_Type is not None:
            showIndent(outfile, level)
            outfile.write('File_Name_Type=%s,\n' % quote_python(self.File_Name_Type).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Order':
            Order_ = child_.text
            Order_ = self.gds_validate_string(Order_, node, 'Order')
            self.Order = Order_
        elif nodeName_ == 'Origin':
            Origin_ = child_.text
            Origin_ = self.gds_validate_string(Origin_, node, 'Origin')
            self.Origin = Origin_
            self.validate_OriginType(self.Origin)    # validate type OriginType
        elif nodeName_ == 'Retrieval_Mode':
            Retrieval_Mode_ = child_.text
            Retrieval_Mode_ = self.gds_validate_string(Retrieval_Mode_, node, 'Retrieval_Mode')
            self.Retrieval_Mode = Retrieval_Mode_
            self.validate_Retrieval_ModeType(self.Retrieval_Mode)    # validate type Retrieval_ModeType
        elif nodeName_ == 'T0':
            sval_ = child_.text
            if sval_:
                try:
                    fval_ = float(sval_)
                except (TypeError, ValueError), exp:
                    raise_parse_error(child_, 'requires float or double: %s' % exp)
            else:
                fval_ = float("0")
            fval_ = self.gds_validate_float(fval_, node, 'T0')
            self.T0 = fval_
        elif nodeName_ == 'T1':
            sval_ = child_.text
            if sval_:
                try:
                    fval_ = float(sval_)
                except (TypeError, ValueError), exp:
                    raise_parse_error(child_, 'requires float or double: %s' % exp)
            else:
                fval_ = float("0")
            fval_ = self.gds_validate_float(fval_, node, 'T1')
            self.T1 = fval_
        elif nodeName_ == 'File_Type':
            File_Type_ = child_.text
            File_Type_ = self.gds_validate_string(File_Type_, node, 'File_Type')
            self.File_Type = File_Type_
        elif nodeName_ == 'File_Name_Type':
            File_Name_Type_ = child_.text
            File_Name_Type_ = self.gds_validate_string(File_Name_Type_, node, 'File_Name_Type')
            self.File_Name_Type = File_Name_Type_
            self.validate_File_Name_TypeType(self.File_Name_Type)    # validate type File_Name_TypeType
# end class AlternativeType


class BreakpointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, File_Name=None, File_Name_Type='Physical'):
        self.original_tagname_ = None
        self.File_Name = File_Name
        self.File_Name_Type = File_Name_Type
    def factory(*args_, **kwargs_):
        if BreakpointType.subclass:
            return BreakpointType.subclass(*args_, **kwargs_)
        else:
            return BreakpointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_File_Name(self): return self.File_Name
    def set_File_Name(self, File_Name): self.File_Name = File_Name
    def get_File_Name_Type(self): return self.File_Name_Type
    def set_File_Name_Type(self, File_Name_Type): self.File_Name_Type = File_Name_Type
    def validate_File_Name_TypeType1(self, value):
        # Validate type File_Name_TypeType1, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.File_Name is not None or
            self.File_Name_Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BreakpointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BreakpointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BreakpointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BreakpointType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BreakpointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.File_Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Name>%s</%sFile_Name>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Name).encode(ExternalEncoding), input_name='File_Name'), namespace_, eol_))
        if self.File_Name_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Name_Type>%s</%sFile_Name_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Name_Type).encode(ExternalEncoding), input_name='File_Name_Type'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='BreakpointType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.File_Name is not None:
            showIndent(outfile, level)
            outfile.write('File_Name=%s,\n' % quote_python(self.File_Name).encode(ExternalEncoding))
        if self.File_Name_Type is not None:
            showIndent(outfile, level)
            outfile.write('File_Name_Type=%s,\n' % quote_python(self.File_Name_Type).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'File_Name':
            File_Name_ = child_.text
            File_Name_ = self.gds_validate_string(File_Name_, node, 'File_Name')
            self.File_Name = File_Name_
        elif nodeName_ == 'File_Name_Type':
            File_Name_Type_ = child_.text
            File_Name_Type_ = self.gds_validate_string(File_Name_Type_, node, 'File_Name_Type')
            self.File_Name_Type = File_Name_Type_
            self.validate_File_Name_TypeType1(self.File_Name_Type)    # validate type File_Name_TypeType1
# end class BreakpointType


class List_of_BreakpointsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Breakpoint=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        if Breakpoint is None:
            self.Breakpoint = []
        else:
            self.Breakpoint = Breakpoint
    def factory(*args_, **kwargs_):
        if List_of_BreakpointsType.subclass:
            return List_of_BreakpointsType.subclass(*args_, **kwargs_)
        else:
            return List_of_BreakpointsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Breakpoint(self): return self.Breakpoint
    def set_Breakpoint(self, Breakpoint): self.Breakpoint = Breakpoint
    def add_Breakpoint(self, value): self.Breakpoint.append(value)
    def insert_Breakpoint(self, index, value): self.Breakpoint[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.Breakpoint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List_of_BreakpointsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List_of_BreakpointsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='List_of_BreakpointsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List_of_BreakpointsType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (self.gds_format_string(quote_attrib(self.count).encode(ExternalEncoding), input_name='count'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='List_of_BreakpointsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Breakpoint_ in self.Breakpoint:
            Breakpoint_.export(outfile, level, namespace_, name_='Breakpoint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='List_of_BreakpointsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count="%s",\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Breakpoint=[\n')
        level += 1
        for Breakpoint_ in self.Breakpoint:
            showIndent(outfile, level)
            outfile.write('model_.BreakpointType(\n')
            Breakpoint_.exportLiteral(outfile, level, name_='BreakpointType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Breakpoint':
            obj_ = BreakpointType.factory()
            obj_.build(child_)
            self.Breakpoint.append(obj_)
            obj_.original_tagname_ = 'Breakpoint'
# end class List_of_BreakpointsType


class OptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Type=None, Value=None, Default=None):
        self.original_tagname_ = None
        self.Name = Name
        self.Type = Type
        self.Value = Value
        self.Default = Default
    def factory(*args_, **kwargs_):
        if OptionType.subclass:
            return OptionType.subclass(*args_, **kwargs_)
        else:
            return OptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_Default(self): return self.Default
    def set_Default(self, Default): self.Default = Default
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Type is not None or
            self.Value is not None or
            self.Default is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
        if self.Default is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefault>%s</%sDefault>%s' % (namespace_, self.gds_format_string(quote_xml(self.Default).encode(ExternalEncoding), input_name='Default'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OptionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
        if self.Default is not None:
            showIndent(outfile, level)
            outfile.write('Default=%s,\n' % quote_python(self.Default).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        elif nodeName_ == 'Default':
            Default_ = child_.text
            Default_ = self.gds_validate_string(Default_, node, 'Default')
            self.Default = Default_
# end class OptionType


class List_of_OptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Option=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        if Option is None:
            self.Option = []
        else:
            self.Option = Option
    def factory(*args_, **kwargs_):
        if List_of_OptionsType.subclass:
            return List_of_OptionsType.subclass(*args_, **kwargs_)
        else:
            return List_of_OptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Option(self): return self.Option
    def set_Option(self, Option): self.Option = Option
    def add_Option(self, value): self.Option.append(value)
    def insert_Option(self, index, value): self.Option[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.Option
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List_of_OptionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List_of_OptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='List_of_OptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List_of_OptionsType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (self.gds_format_string(quote_attrib(self.count).encode(ExternalEncoding), input_name='count'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='List_of_OptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Option_ in self.Option:
            Option_.export(outfile, level, namespace_, name_='Option', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='List_of_OptionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count="%s",\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Option=[\n')
        level += 1
        for Option_ in self.Option:
            showIndent(outfile, level)
            outfile.write('model_.OptionType(\n')
            Option_.exportLiteral(outfile, level, name_='OptionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Option':
            obj_ = OptionType.factory()
            obj_.build(child_)
            self.Option.append(obj_)
            obj_.original_tagname_ = 'Option'
# end class List_of_OptionsType


class Min_Disk_SpaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=None):
        self.original_tagname_ = None
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Min_Disk_SpaceType.subclass:
            return Min_Disk_SpaceType.subclass(*args_, **kwargs_)
        else:
            return Min_Disk_SpaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Min_Disk_SpaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Min_Disk_SpaceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Min_Disk_SpaceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Min_Disk_SpaceType'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Min_Disk_SpaceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Min_Disk_SpaceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            showIndent(outfile, level)
            outfile.write('units="%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Min_Disk_SpaceType


class List_of_InputsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Input=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        if Input is None:
            self.Input = []
        else:
            self.Input = Input
    def factory(*args_, **kwargs_):
        if List_of_InputsType.subclass:
            return List_of_InputsType.subclass(*args_, **kwargs_)
        else:
            return List_of_InputsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Input(self): return self.Input
    def set_Input(self, Input): self.Input = Input
    def add_Input(self, value): self.Input.append(value)
    def insert_Input(self, index, value): self.Input[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.Input
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List_of_InputsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List_of_InputsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='List_of_InputsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List_of_InputsType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (self.gds_format_string(quote_attrib(self.count).encode(ExternalEncoding), input_name='count'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='List_of_InputsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Input_ in self.Input:
            Input_.export(outfile, level, namespace_, name_='Input', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='List_of_InputsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count="%s",\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Input=[\n')
        level += 1
        for Input_ in self.Input:
            showIndent(outfile, level)
            outfile.write('model_.InputType(\n')
            Input_.exportLiteral(outfile, level, name_='InputType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Input':
            obj_ = InputType.factory()
            obj_.build(child_)
            self.Input.append(obj_)
            obj_.original_tagname_ = 'Input'
# end class List_of_InputsType


class Ipf_Task_TableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Processor_Name=None, Version=None, Test=None, Min_Disk_Space=None, Max_Time=None, Sensing_Time_Flag=False, List_of_Cfg_Files=None, List_of_Dyn_ProcParam=None, List_of_Pools=None):
        self.original_tagname_ = None
        self.Processor_Name = Processor_Name
        self.Version = Version
        self.Test = Test
        if Min_Disk_Space is None:
            self.Min_Disk_Space = globals()['MinDiskSpaceType']('1024')
        else:
            self.Min_Disk_Space = Min_Disk_Space
        if Max_Time is None:
            self.Max_Time = globals()['MaxTimeType']('0')
        else:
            self.Max_Time = Max_Time
        self.Sensing_Time_Flag = Sensing_Time_Flag
        self.List_of_Cfg_Files = List_of_Cfg_Files
        self.List_of_Dyn_ProcParam = List_of_Dyn_ProcParam
        self.List_of_Pools = List_of_Pools
    def factory(*args_, **kwargs_):
        if Ipf_Task_TableType.subclass:
            return Ipf_Task_TableType.subclass(*args_, **kwargs_)
        else:
            return Ipf_Task_TableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Processor_Name(self): return self.Processor_Name
    def set_Processor_Name(self, Processor_Name): self.Processor_Name = Processor_Name
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Test(self): return self.Test
    def set_Test(self, Test): self.Test = Test
    def get_Min_Disk_Space(self): return self.Min_Disk_Space
    def set_Min_Disk_Space(self, Min_Disk_Space): self.Min_Disk_Space = Min_Disk_Space
    def get_Max_Time(self): return self.Max_Time
    def set_Max_Time(self, Max_Time): self.Max_Time = Max_Time
    def get_Sensing_Time_Flag(self): return self.Sensing_Time_Flag
    def set_Sensing_Time_Flag(self, Sensing_Time_Flag): self.Sensing_Time_Flag = Sensing_Time_Flag
    def get_List_of_Cfg_Files(self): return self.List_of_Cfg_Files
    def set_List_of_Cfg_Files(self, List_of_Cfg_Files): self.List_of_Cfg_Files = List_of_Cfg_Files
    def get_List_of_Dyn_ProcParam(self): return self.List_of_Dyn_ProcParam
    def set_List_of_Dyn_ProcParam(self, List_of_Dyn_ProcParam): self.List_of_Dyn_ProcParam = List_of_Dyn_ProcParam
    def get_List_of_Pools(self): return self.List_of_Pools
    def set_List_of_Pools(self, List_of_Pools): self.List_of_Pools = List_of_Pools
    def validate_TestType(self, value):
        # Validate type TestType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Processor_Name is not None or
            self.Version is not None or
            self.Test is not None or
            self.Min_Disk_Space is not None or
            self.Max_Time is not None or
            self.Sensing_Time_Flag is not None or
            self.List_of_Cfg_Files is not None or
            self.List_of_Dyn_ProcParam is not None or
            self.List_of_Pools is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Ipf_Task_TableType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Ipf_Task_TableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Ipf_Task_TableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Ipf_Task_TableType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Ipf_Task_TableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Processor_Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProcessor_Name>%s</%sProcessor_Name>%s' % (namespace_, self.gds_format_string(quote_xml(self.Processor_Name).encode(ExternalEncoding), input_name='Processor_Name'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Test is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTest>%s</%sTest>%s' % (namespace_, self.gds_format_string(quote_xml(self.Test).encode(ExternalEncoding), input_name='Test'), namespace_, eol_))
        if self.Min_Disk_Space is not None:
            self.Min_Disk_Space.export(outfile, level, namespace_, name_='Min_Disk_Space', pretty_print=pretty_print)
        if self.Max_Time is not None:
            self.Max_Time.export(outfile, level, namespace_, name_='Max_Time', pretty_print=pretty_print)
        if self.Sensing_Time_Flag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSensing_Time_Flag>%s</%sSensing_Time_Flag>%s' % (namespace_, self.gds_format_boolean(self.Sensing_Time_Flag, input_name='Sensing_Time_Flag'), namespace_, eol_))
        if self.List_of_Cfg_Files is not None:
            self.List_of_Cfg_Files.export(outfile, level, namespace_, name_='List_of_Cfg_Files', pretty_print=pretty_print)
        if self.List_of_Dyn_ProcParam is not None:
            self.List_of_Dyn_ProcParam.export(outfile, level, namespace_, name_='List_of_Dyn_ProcParam', pretty_print=pretty_print)
        if self.List_of_Pools is not None:
            self.List_of_Pools.export(outfile, level, namespace_, name_='List_of_Pools', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Ipf_Task_TableType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Processor_Name is not None:
            showIndent(outfile, level)
            outfile.write('Processor_Name=%s,\n' % quote_python(self.Processor_Name).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Test is not None:
            showIndent(outfile, level)
            outfile.write('Test=%s,\n' % quote_python(self.Test).encode(ExternalEncoding))
        if self.Min_Disk_Space is not None:
            showIndent(outfile, level)
            outfile.write('Min_Disk_Space=model_.MinDiskSpaceType(\n')
            self.Min_Disk_Space.exportLiteral(outfile, level, name_='Min_Disk_Space')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Max_Time is not None:
            showIndent(outfile, level)
            outfile.write('Max_Time=model_.MaxTimeType(\n')
            self.Max_Time.exportLiteral(outfile, level, name_='Max_Time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Sensing_Time_Flag is not None:
            showIndent(outfile, level)
            outfile.write('Sensing_Time_Flag=%s,\n' % self.Sensing_Time_Flag)
        if self.List_of_Cfg_Files is not None:
            showIndent(outfile, level)
            outfile.write('List_of_Cfg_Files=model_.List_of_Cfg_FilesType(\n')
            self.List_of_Cfg_Files.exportLiteral(outfile, level, name_='List_of_Cfg_Files')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.List_of_Dyn_ProcParam is not None:
            showIndent(outfile, level)
            outfile.write('List_of_Dyn_ProcParam=model_.List_of_Dyn_ProcParamType(\n')
            self.List_of_Dyn_ProcParam.exportLiteral(outfile, level, name_='List_of_Dyn_ProcParam')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.List_of_Pools is not None:
            showIndent(outfile, level)
            outfile.write('List_of_Pools=model_.List_of_PoolsType(\n')
            self.List_of_Pools.exportLiteral(outfile, level, name_='List_of_Pools')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Processor_Name':
            Processor_Name_ = child_.text
            Processor_Name_ = self.gds_validate_string(Processor_Name_, node, 'Processor_Name')
            self.Processor_Name = Processor_Name_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Test':
            Test_ = child_.text
            Test_ = self.gds_validate_string(Test_, node, 'Test')
            self.Test = Test_
            self.validate_TestType(self.Test)    # validate type TestType
        elif nodeName_ == 'Min_Disk_Space':
            obj_ = MinDiskSpaceType.factory()
            obj_.build(child_)
            self.Min_Disk_Space = obj_
            obj_.original_tagname_ = 'Min_Disk_Space'
        elif nodeName_ == 'Max_Time':
            obj_ = MaxTimeType.factory()
            obj_.build(child_)
            self.Max_Time = obj_
            obj_.original_tagname_ = 'Max_Time'
        elif nodeName_ == 'Sensing_Time_Flag':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Sensing_Time_Flag')
            self.Sensing_Time_Flag = ival_
        elif nodeName_ == 'List_of_Cfg_Files':
            obj_ = List_of_Cfg_FilesType.factory()
            obj_.build(child_)
            self.List_of_Cfg_Files = obj_
            obj_.original_tagname_ = 'List_of_Cfg_Files'
        elif nodeName_ == 'List_of_Dyn_ProcParam':
            obj_ = List_of_Dyn_ProcParamType.factory()
            obj_.build(child_)
            self.List_of_Dyn_ProcParam = obj_
            obj_.original_tagname_ = 'List_of_Dyn_ProcParam'
        elif nodeName_ == 'List_of_Pools':
            obj_ = List_of_PoolsType.factory()
            obj_.build(child_)
            self.List_of_Pools = obj_
            obj_.original_tagname_ = 'List_of_Pools'
# end class Ipf_Task_TableType


class List_of_AlternativesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Alternative=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        self.Alternative = Alternative
    def factory(*args_, **kwargs_):
        if List_of_AlternativesType.subclass:
            return List_of_AlternativesType.subclass(*args_, **kwargs_)
        else:
            return List_of_AlternativesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Alternative(self): return self.Alternative
    def set_Alternative(self, Alternative): self.Alternative = Alternative
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.Alternative is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List_of_AlternativesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List_of_AlternativesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='List_of_AlternativesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List_of_AlternativesType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (self.gds_format_string(quote_attrib(self.count).encode(ExternalEncoding), input_name='count'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='List_of_AlternativesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Alternative is not None:
            self.Alternative.export(outfile, level, namespace_, name_='Alternative', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='List_of_AlternativesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count="%s",\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Alternative is not None:
            showIndent(outfile, level)
            outfile.write('Alternative=model_.AlternativeType(\n')
            self.Alternative.exportLiteral(outfile, level, name_='Alternative')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Alternative':
            obj_ = AlternativeType.factory()
            obj_.build(child_)
            self.Alternative = obj_
            obj_.original_tagname_ = 'Alternative'
# end class List_of_AlternativesType


class List_of_PoolsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Pool=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        if Pool is None:
            self.Pool = []
        else:
            self.Pool = Pool
    def factory(*args_, **kwargs_):
        if List_of_PoolsType.subclass:
            return List_of_PoolsType.subclass(*args_, **kwargs_)
        else:
            return List_of_PoolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Pool(self): return self.Pool
    def set_Pool(self, Pool): self.Pool = Pool
    def add_Pool(self, value): self.Pool.append(value)
    def insert_Pool(self, index, value): self.Pool[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.Pool
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List_of_PoolsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List_of_PoolsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='List_of_PoolsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List_of_PoolsType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (self.gds_format_string(quote_attrib(self.count).encode(ExternalEncoding), input_name='count'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='List_of_PoolsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Pool_ in self.Pool:
            Pool_.export(outfile, level, namespace_, name_='Pool', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='List_of_PoolsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count="%s",\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Pool=[\n')
        level += 1
        for Pool_ in self.Pool:
            showIndent(outfile, level)
            outfile.write('model_.PoolType(\n')
            Pool_.exportLiteral(outfile, level, name_='PoolType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Pool':
            obj_ = PoolType.factory()
            obj_.build(child_)
            self.Pool.append(obj_)
            obj_.original_tagname_ = 'Pool'
# end class List_of_PoolsType


class List_of_Dyn_ProcParamType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Dyn_ProcParam=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        if Dyn_ProcParam is None:
            self.Dyn_ProcParam = []
        else:
            self.Dyn_ProcParam = Dyn_ProcParam
    def factory(*args_, **kwargs_):
        if List_of_Dyn_ProcParamType.subclass:
            return List_of_Dyn_ProcParamType.subclass(*args_, **kwargs_)
        else:
            return List_of_Dyn_ProcParamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dyn_ProcParam(self): return self.Dyn_ProcParam
    def set_Dyn_ProcParam(self, Dyn_ProcParam): self.Dyn_ProcParam = Dyn_ProcParam
    def add_Dyn_ProcParam(self, value): self.Dyn_ProcParam.append(value)
    def insert_Dyn_ProcParam(self, index, value): self.Dyn_ProcParam[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.Dyn_ProcParam
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List_of_Dyn_ProcParamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List_of_Dyn_ProcParamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='List_of_Dyn_ProcParamType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List_of_Dyn_ProcParamType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (self.gds_format_string(quote_attrib(self.count).encode(ExternalEncoding), input_name='count'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='List_of_Dyn_ProcParamType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Dyn_ProcParam_ in self.Dyn_ProcParam:
            Dyn_ProcParam_.export(outfile, level, namespace_, name_='Dyn_ProcParam', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='List_of_Dyn_ProcParamType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count="%s",\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Dyn_ProcParam=[\n')
        level += 1
        for Dyn_ProcParam_ in self.Dyn_ProcParam:
            showIndent(outfile, level)
            outfile.write('model_.Dyn_ProcParamType(\n')
            Dyn_ProcParam_.exportLiteral(outfile, level, name_='Dyn_ProcParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Dyn_ProcParam':
            obj_ = Dyn_ProcParamType.factory()
            obj_.build(child_)
            self.Dyn_ProcParam.append(obj_)
            obj_.original_tagname_ = 'Dyn_ProcParam'
# end class List_of_Dyn_ProcParamType


class TaskType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Version=None, Critical=None, Criticality_Level=None, File_Name=None, List_of_Inputs=None, List_of_Outputs=None, List_of_Breakpoints=None, NumberOfCPUs=None, List_of_Options=None):
        self.original_tagname_ = None
        self.Name = Name
        self.Version = Version
        self.Critical = Critical
        self.Criticality_Level = Criticality_Level
        self.File_Name = File_Name
        self.List_of_Inputs = List_of_Inputs
        self.List_of_Outputs = List_of_Outputs
        self.List_of_Breakpoints = List_of_Breakpoints
        self.NumberOfCPUs = NumberOfCPUs
        self.List_of_Options = List_of_Options
    def factory(*args_, **kwargs_):
        if TaskType.subclass:
            return TaskType.subclass(*args_, **kwargs_)
        else:
            return TaskType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Critical(self): return self.Critical
    def set_Critical(self, Critical): self.Critical = Critical
    def get_Criticality_Level(self): return self.Criticality_Level
    def set_Criticality_Level(self, Criticality_Level): self.Criticality_Level = Criticality_Level
    def get_File_Name(self): return self.File_Name
    def set_File_Name(self, File_Name): self.File_Name = File_Name
    def get_List_of_Inputs(self): return self.List_of_Inputs
    def set_List_of_Inputs(self, List_of_Inputs): self.List_of_Inputs = List_of_Inputs
    def get_List_of_Outputs(self): return self.List_of_Outputs
    def set_List_of_Outputs(self, List_of_Outputs): self.List_of_Outputs = List_of_Outputs
    def get_List_of_Breakpoints(self): return self.List_of_Breakpoints
    def set_List_of_Breakpoints(self, List_of_Breakpoints): self.List_of_Breakpoints = List_of_Breakpoints
    def get_NumberOfCPUs(self): return self.NumberOfCPUs
    def set_NumberOfCPUs(self, NumberOfCPUs): self.NumberOfCPUs = NumberOfCPUs
    def get_List_of_Options(self): return self.List_of_Options
    def set_List_of_Options(self, List_of_Options): self.List_of_Options = List_of_Options
    def validate_Criticality_LevelType(self, value):
        # Validate type Criticality_LevelType, a restriction on xs:integer.
        pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Version is not None or
            self.Critical is not None or
            self.Criticality_Level is not None or
            self.File_Name is not None or
            self.List_of_Inputs is not None or
            self.List_of_Outputs is not None or
            self.List_of_Breakpoints is not None or
            self.NumberOfCPUs is not None or
            self.List_of_Options is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaskType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaskType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaskType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaskType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TaskType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Critical is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCritical>%s</%sCritical>%s' % (namespace_, self.gds_format_boolean(self.Critical, input_name='Critical'), namespace_, eol_))
        if self.Criticality_Level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCriticality_Level>%s</%sCriticality_Level>%s' % (namespace_, self.gds_format_integer(self.Criticality_Level, input_name='Criticality_Level'), namespace_, eol_))
        if self.File_Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Name>%s</%sFile_Name>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Name).encode(ExternalEncoding), input_name='File_Name'), namespace_, eol_))
        if self.List_of_Inputs is not None:
            self.List_of_Inputs.export(outfile, level, namespace_, name_='List_of_Inputs', pretty_print=pretty_print)
        if self.List_of_Outputs is not None:
            self.List_of_Outputs.export(outfile, level, namespace_, name_='List_of_Outputs', pretty_print=pretty_print)
        if self.List_of_Breakpoints is not None:
            self.List_of_Breakpoints.export(outfile, level, namespace_, name_='List_of_Breakpoints', pretty_print=pretty_print)
        if self.NumberOfCPUs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfCPUs>%s</%sNumberOfCPUs>%s' % (namespace_, self.gds_format_integer(self.NumberOfCPUs, input_name='NumberOfCPUs'), namespace_, eol_))
        if self.List_of_Options is not None:
            self.List_of_Options.export(outfile, level, namespace_, name_='List_of_Options', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TaskType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Critical is not None:
            showIndent(outfile, level)
            outfile.write('Critical=%s,\n' % self.Critical)
        if self.Criticality_Level is not None:
            showIndent(outfile, level)
            outfile.write('Criticality_Level=%d,\n' % self.Criticality_Level)
        if self.File_Name is not None:
            showIndent(outfile, level)
            outfile.write('File_Name=%s,\n' % quote_python(self.File_Name).encode(ExternalEncoding))
        if self.List_of_Inputs is not None:
            showIndent(outfile, level)
            outfile.write('List_of_Inputs=model_.List_of_InputsType(\n')
            self.List_of_Inputs.exportLiteral(outfile, level, name_='List_of_Inputs')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.List_of_Outputs is not None:
            showIndent(outfile, level)
            outfile.write('List_of_Outputs=model_.List_of_OutputsType(\n')
            self.List_of_Outputs.exportLiteral(outfile, level, name_='List_of_Outputs')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.List_of_Breakpoints is not None:
            showIndent(outfile, level)
            outfile.write('List_of_Breakpoints=model_.List_of_BreakpointsType(\n')
            self.List_of_Breakpoints.exportLiteral(outfile, level, name_='List_of_Breakpoints')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NumberOfCPUs is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfCPUs=%d,\n' % self.NumberOfCPUs)
        if self.List_of_Options is not None:
            showIndent(outfile, level)
            outfile.write('List_of_Options=model_.List_of_OptionsType(\n')
            self.List_of_Options.exportLiteral(outfile, level, name_='List_of_Options')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Critical':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Critical')
            self.Critical = ival_
        elif nodeName_ == 'Criticality_Level':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Criticality_Level')
            self.Criticality_Level = ival_
            self.validate_Criticality_LevelType(self.Criticality_Level)    # validate type Criticality_LevelType
        elif nodeName_ == 'File_Name':
            File_Name_ = child_.text
            File_Name_ = self.gds_validate_string(File_Name_, node, 'File_Name')
            self.File_Name = File_Name_
        elif nodeName_ == 'List_of_Inputs':
            obj_ = List_of_InputsType.factory()
            obj_.build(child_)
            self.List_of_Inputs = obj_
            obj_.original_tagname_ = 'List_of_Inputs'
        elif nodeName_ == 'List_of_Outputs':
            obj_ = List_of_OutputsType.factory()
            obj_.build(child_)
            self.List_of_Outputs = obj_
            obj_.original_tagname_ = 'List_of_Outputs'
        elif nodeName_ == 'List_of_Breakpoints':
            obj_ = List_of_BreakpointsType.factory()
            obj_.build(child_)
            self.List_of_Breakpoints = obj_
            obj_.original_tagname_ = 'List_of_Breakpoints'
        elif nodeName_ == 'NumberOfCPUs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfCPUs')
            self.NumberOfCPUs = ival_
        elif nodeName_ == 'List_of_Options':
            obj_ = List_of_OptionsType.factory()
            obj_.build(child_)
            self.List_of_Options = obj_
            obj_.original_tagname_ = 'List_of_Options'
# end class TaskType


class OutputType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Destination='DB', Mandatory='Yes', Type=None, File_Name_Type='Physical'):
        self.original_tagname_ = None
        self.Destination = Destination
        self.Mandatory = Mandatory
        self.Type = Type
        self.File_Name_Type = File_Name_Type
    def factory(*args_, **kwargs_):
        if OutputType.subclass:
            return OutputType.subclass(*args_, **kwargs_)
        else:
            return OutputType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Destination(self): return self.Destination
    def set_Destination(self, Destination): self.Destination = Destination
    def get_Mandatory(self): return self.Mandatory
    def set_Mandatory(self, Mandatory): self.Mandatory = Mandatory
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_File_Name_Type(self): return self.File_Name_Type
    def set_File_Name_Type(self, File_Name_Type): self.File_Name_Type = File_Name_Type
    def validate_DestinationType(self, value):
        # Validate type DestinationType, a restriction on xs:string.
        pass
    def validate_MandatoryType2(self, value):
        # Validate type MandatoryType2, a restriction on xs:string.
        pass
    def validate_File_Name_TypeType3(self, value):
        # Validate type File_Name_TypeType3, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Destination is not None or
            self.Mandatory is not None or
            self.Type is not None or
            self.File_Name_Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OutputType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutputType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OutputType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OutputType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OutputType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Destination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestination>%s</%sDestination>%s' % (namespace_, self.gds_format_string(quote_xml(self.Destination).encode(ExternalEncoding), input_name='Destination'), namespace_, eol_))
        if self.Mandatory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMandatory>%s</%sMandatory>%s' % (namespace_, self.gds_format_string(quote_xml(self.Mandatory).encode(ExternalEncoding), input_name='Mandatory'), namespace_, eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_, eol_))
        if self.File_Name_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Name_Type>%s</%sFile_Name_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Name_Type).encode(ExternalEncoding), input_name='File_Name_Type'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OutputType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Destination is not None:
            showIndent(outfile, level)
            outfile.write('Destination=%s,\n' % quote_python(self.Destination).encode(ExternalEncoding))
        if self.Mandatory is not None:
            showIndent(outfile, level)
            outfile.write('Mandatory=%s,\n' % quote_python(self.Mandatory).encode(ExternalEncoding))
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.File_Name_Type is not None:
            showIndent(outfile, level)
            outfile.write('File_Name_Type=%s,\n' % quote_python(self.File_Name_Type).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Destination':
            Destination_ = child_.text
            Destination_ = self.gds_validate_string(Destination_, node, 'Destination')
            self.Destination = Destination_
            self.validate_DestinationType(self.Destination)    # validate type DestinationType
        elif nodeName_ == 'Mandatory':
            Mandatory_ = child_.text
            Mandatory_ = self.gds_validate_string(Mandatory_, node, 'Mandatory')
            self.Mandatory = Mandatory_
            self.validate_MandatoryType2(self.Mandatory)    # validate type MandatoryType2
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'File_Name_Type':
            File_Name_Type_ = child_.text
            File_Name_Type_ = self.gds_validate_string(File_Name_Type_, node, 'File_Name_Type')
            self.File_Name_Type = File_Name_Type_
            self.validate_File_Name_TypeType3(self.File_Name_Type)    # validate type File_Name_TypeType3
# end class OutputType


class List_of_OutputsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Output=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        if Output is None:
            self.Output = []
        else:
            self.Output = Output
    def factory(*args_, **kwargs_):
        if List_of_OutputsType.subclass:
            return List_of_OutputsType.subclass(*args_, **kwargs_)
        else:
            return List_of_OutputsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def add_Output(self, value): self.Output.append(value)
    def insert_Output(self, index, value): self.Output[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.Output
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List_of_OutputsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List_of_OutputsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='List_of_OutputsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List_of_OutputsType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (self.gds_format_string(quote_attrib(self.count).encode(ExternalEncoding), input_name='count'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='List_of_OutputsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Output_ in self.Output:
            Output_.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='List_of_OutputsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count="%s",\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Output=[\n')
        level += 1
        for Output_ in self.Output:
            showIndent(outfile, level)
            outfile.write('model_.OutputType(\n')
            Output_.exportLiteral(outfile, level, name_='OutputType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Output':
            obj_ = OutputType.factory()
            obj_.build(child_)
            self.Output.append(obj_)
            obj_.original_tagname_ = 'Output'
# end class List_of_OutputsType


class Dyn_ProcParamType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Param_Name=None, Param_Type=None, Param_Default=None):
        self.original_tagname_ = None
        if Param_Name is None:
            self.Param_Name = []
        else:
            self.Param_Name = Param_Name
        if Param_Type is None:
            self.Param_Type = []
        else:
            self.Param_Type = Param_Type
        self.Param_Default = Param_Default
    def factory(*args_, **kwargs_):
        if Dyn_ProcParamType.subclass:
            return Dyn_ProcParamType.subclass(*args_, **kwargs_)
        else:
            return Dyn_ProcParamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Param_Name(self): return self.Param_Name
    def set_Param_Name(self, Param_Name): self.Param_Name = Param_Name
    def add_Param_Name(self, value): self.Param_Name.append(value)
    def insert_Param_Name(self, index, value): self.Param_Name[index] = value
    def get_Param_Type(self): return self.Param_Type
    def set_Param_Type(self, Param_Type): self.Param_Type = Param_Type
    def add_Param_Type(self, value): self.Param_Type.append(value)
    def insert_Param_Type(self, index, value): self.Param_Type[index] = value
    def get_Param_Default(self): return self.Param_Default
    def set_Param_Default(self, Param_Default): self.Param_Default = Param_Default
    def hasContent_(self):
        if (
            self.Param_Name or
            self.Param_Type or
            self.Param_Default is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Dyn_ProcParamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Dyn_ProcParamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Dyn_ProcParamType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Dyn_ProcParamType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Dyn_ProcParamType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Param_Name_ in self.Param_Name:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParam_Name>%s</%sParam_Name>%s' % (namespace_, self.gds_format_string(quote_xml(Param_Name_).encode(ExternalEncoding), input_name='Param_Name'), namespace_, eol_))
        for Param_Type_ in self.Param_Type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParam_Type>%s</%sParam_Type>%s' % (namespace_, self.gds_format_string(quote_xml(Param_Type_).encode(ExternalEncoding), input_name='Param_Type'), namespace_, eol_))
        if self.Param_Default is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParam_Default>%s</%sParam_Default>%s' % (namespace_, self.gds_format_string(quote_xml(self.Param_Default).encode(ExternalEncoding), input_name='Param_Default'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Dyn_ProcParamType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Param_Name=[\n')
        level += 1
        for Param_Name_ in self.Param_Name:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Param_Name_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Param_Type=[\n')
        level += 1
        for Param_Type_ in self.Param_Type:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Param_Type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Param_Default is not None:
            showIndent(outfile, level)
            outfile.write('Param_Default=%s,\n' % quote_python(self.Param_Default).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Param_Name':
            Param_Name_ = child_.text
            Param_Name_ = self.gds_validate_string(Param_Name_, node, 'Param_Name')
            self.Param_Name.append(Param_Name_)
        elif nodeName_ == 'Param_Type':
            Param_Type_ = child_.text
            Param_Type_ = self.gds_validate_string(Param_Type_, node, 'Param_Type')
            self.Param_Type.append(Param_Type_)
        elif nodeName_ == 'Param_Default':
            Param_Default_ = child_.text
            Param_Default_ = self.gds_validate_string(Param_Default_, node, 'Param_Default')
            self.Param_Default = Param_Default_
# end class Dyn_ProcParamType


class MinDiskSpaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=None):
        self.original_tagname_ = None
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MinDiskSpaceType.subclass:
            return MinDiskSpaceType.subclass(*args_, **kwargs_)
        else:
            return MinDiskSpaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MinDiskSpaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MinDiskSpaceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MinDiskSpaceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MinDiskSpaceType'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MinDiskSpaceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MinDiskSpaceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            showIndent(outfile, level)
            outfile.write('units="%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MinDiskSpaceType


class MaxTimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=None):
        self.original_tagname_ = None
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MaxTimeType.subclass:
            return MaxTimeType.subclass(*args_, **kwargs_)
        else:
            return MaxTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MaxTimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MaxTimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MaxTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MaxTimeType'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MaxTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MaxTimeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            showIndent(outfile, level)
            outfile.write('units="%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MaxTimeType


class Cfg_FilesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Version=None, File_Name=None):
        self.original_tagname_ = None
        self.Version = Version
        self.File_Name = File_Name
    def factory(*args_, **kwargs_):
        if Cfg_FilesType.subclass:
            return Cfg_FilesType.subclass(*args_, **kwargs_)
        else:
            return Cfg_FilesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_File_Name(self): return self.File_Name
    def set_File_Name(self, File_Name): self.File_Name = File_Name
    def hasContent_(self):
        if (
            self.Version is not None or
            self.File_Name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Cfg_FilesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cfg_FilesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Cfg_FilesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cfg_FilesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Cfg_FilesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.File_Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Name>%s</%sFile_Name>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Name).encode(ExternalEncoding), input_name='File_Name'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Cfg_FilesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.File_Name is not None:
            showIndent(outfile, level)
            outfile.write('File_Name=%s,\n' % quote_python(self.File_Name).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'File_Name':
            File_Name_ = child_.text
            File_Name_ = self.gds_validate_string(File_Name_, node, 'File_Name')
            self.File_Name = File_Name_
# end class Cfg_FilesType


GDSClassesMapping = {
    'List_of_Dyn_ProcParam': List_of_Dyn_ProcParamType,
    'List_of_Tasks': List_of_TasksType,
    'Task': TaskType,
    'Option': OptionType,
    'Ipf_Task_Table': Ipf_Task_TableType,
    'List_of_Inputs': List_of_InputsType,
    'Dyn_ProcParam': Dyn_ProcParamType,
    'Cfg_File': Cfg_FilesType,
    'List_of_Breakpoints': List_of_BreakpointsType,
    'List_of_Alternatives': List_of_AlternativesType,
    'Min_Disk_Space': MinDiskSpaceType,
    'Output': OutputType,
    'Pool': PoolType,
    'Max_Time': MaxTimeType,
    'Breakpoint': BreakpointType,
    'List_of_Outputs': List_of_OutputsType,
    'Input': InputType,
    'Alternative': AlternativeType,
    'List_of_Pools': List_of_PoolsType,
    'List_of_Cfg_Files': List_of_Cfg_FilesType,
    'List_of_Options': List_of_OptionsType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Ipf_Task_TableType'
        rootClass = Ipf_Task_TableType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Ipf_Task_TableType'
        rootClass = Ipf_Task_TableType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Ipf_Task_TableType'
        rootClass = Ipf_Task_TableType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Ipf_Task_TableType'
        rootClass = Ipf_Task_TableType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from TaskTableReader import *\n\n')
        sys.stdout.write('import TaskTableReader as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AlternativeType",
    "BreakpointType",
    "Cfg_FilesType",
    "Dyn_ProcParamType",
    "InputType",
    "Ipf_Task_TableType",
    "List_of_AlternativesType",
    "List_of_BreakpointsType",
    "List_of_Cfg_FilesType",
    "List_of_Dyn_ProcParamType",
    "List_of_InputsType",
    "List_of_OptionsType",
    "List_of_OutputsType",
    "List_of_PoolsType",
    "List_of_TasksType",
    "MaxTimeType",
    "MinDiskSpaceType",
    "Min_Disk_SpaceType",
    "OptionType",
    "OutputType",
    "PoolType",
    "TaskType"
]
